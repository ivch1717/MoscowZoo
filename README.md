# Homework 1

**Выполнил:** Чичаев Иван БПИ-249

## Инструкция по сборке и запуску

1. Клонировать репозиторий:
   ```bash
   git clone https://github.com/ivch1717/MoscowZoo
   ```

2. Перейти в корневую папку проекта MoscowZoo:
   ```bash
   cd MoscowZoo
   ```

3. В корневой папке MoscowZoo выполнить сборку:
   ```bash
   dotnet build
   ```

4. Запустить консольное приложение MoscowZoo из корневой папки через Run.

5. Запуск юнит-тестов из корневой папки или Run Unit Tests для MoscowZoo.Tests:
   ```bash
   dotnet test
   ```

## Как пользоваться

В меню ориентироваться с помощью стрелок и нажимать Enter. Остальное вводится с клавиатуры.

## Применение SOLID принципов

### S - Single Responsibility Principle (Принцип единственной ответственности)

- `InformAnimalField` - только информация о полях животных
- `VeterenaryClinic` - только логика проверки здоровья животных
- `AnimalService` - только бизнес-логика животных
- `AnimalRepository` - только логика хранения и изменения животных
- `MonkeyFabric` - только создание обезьян
- `InputService` - только различное считывание с консоли
- `OutputService` - только вывод и работа с консолью
- `Menu` - только работу с меню через клавиши

И т.д. Абсолютно каждый класс удовлетворяет этому принципу и отвечает только за свою задачу.

### O - Open/Closed Principle (Принцип открытости/закрытости)

Легко добавить новое животное без изменения существующего кода:

```csharp
public class Elephant : Herbo { }
public class ElephantFabric : IAnimalFabric { }
// Добавить в FactoryAnimalResolver
```

И т.д. в других местах. Чтобы добавить новый функционал, нам не надо изменять уже существующий.

Интерфейсы позволяют расширять функциональность: можно написать другой `AnimalRepository`, который будет хранить и доставать животных в базе данных или JSON. Просто изменить DI-контейнер, и он будет передаваться в `AnimalService` без изменения уже существующего кода. Или изменить логику `ThingValidator` и написать другую реализацию интерфейса.

### L - Liskov Substitution Principle (Принцип подстановки Лисков)

- `Wolf : Predator : Animal` - все потомки корректно заменяют родителей
- `Rabbit : Herbo : Animal` - соблюдена семантика наследования

`Herbo` и `Predator` расширяют `Animal`, но они не противоречат ему, они корректно работают там, где мы принимаем `Animal`. Поведение базового типа корректно реализовано для всех его наследников. Аналогично все соответствует и для других классов животных и `Thing`. Все реализации интерфейсов полностью их реализуют.

### I - Interface Segregation Principle (Принцип разделения интерфейсов)

- `IInformAnimalField` - только работа с полями животных
- `IVeterenaryClinic` - только проверка здоровья животных
- `IAnimalService` - только действия и функции с животными
- `IAnimalRepository` - только хранение и изменение животных
- `IMonkeyFabric` - только создание обезьян
- `IInputService` - только различное считывание
- `IOutputService` - только вывод
- `IMenu` - только работу с меню через клавиши

И т.д. Абсолютно каждый интерфейс удовлетворяет этому принципу и отвечает только за свою задачу. Все классы реализуют только те методы, что им нужны.

### D - Dependency Inversion Principle (Принцип инверсии зависимостей)

Буквально весь проект об этом. Все зависит только от абстракций. Все классы связаны только через DI-контейнер и интерфейсы, а не напрямую.

**Пример:**
```csharp
// Зависимость от абстракций, а не реализаций:
public class AnimalService
{
    private readonly IAnimalRepository _repository;    
    private readonly IFactoryAnimalResolver _resolver;
    private readonly IVeterinaryClinic _clinic;       
}
```

**Применение DI-контейнера:**
Использован контейнер зависимостей .NET (Microsoft.Extensions.DependencyInjection). Абсолютно все классы, которые имеют зависимости, не создаются через `new`, а хранят нужный интерфейс и получают их через внедрение от DI-контейнера.

## Тестирование

Создан проект MoscowZoo.Tests с фреймворком xUnit. Покрытие консольного приложения тестами - 64%.
